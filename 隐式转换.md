4.26笔记

# 隐式转换

Java中的类型转换包括自动类型转换(隐式类型转换), 强制类型转换

**自动类型转换**:将小范围的类型向大范围类型转换, 转换中不会发生数据丢失

byte -> short ->int-> long -> float -> double

char -> int

> boolean类型不能参与到表达式的运算中

**字符集**

char类型的本质是整数数值, 输出时会按照ascii编码翻译成对应的字符

实质上char类型存储了16位的无符号整数(无符号代表它没有符号位, 可以存储2的15次方数据)

>Java中的字符串是默认使用16位的Unicode编码来存储数据

> 疑问:char类型有2个字节(16位), 可以存储65535个字符, 但是ASCII码只有128个字符
>
> 那么129之后的值是按照什么规则来转换成字符的

ASCII: 单字节的字符集码表, 包含128个字符(其中前32个字符无法打印, 后96个字符可以打印)

UTF-8: 包括了世界上大部分语言的文字的字符集码表, 父集是Unicode, 为变长字符集, 其大小会根据存储的字符不同而变化

GBK: 中国研发的字符集, 可以表示中文



byte a=1,b=2,c=a+b;

上述代码会报错, 因为a+b表达式的结果是整数型, 整数值默认是int类型

> 在移位运算时表达式中的整数型(byte short char)在参与运算时会发生自动类型转换, 自动转换成int类型的数值再参与表达式的运算

> 在java中默认整数类型为int 默认浮点数类型为double



# 强制转换

强制类型转换会发生数据丢失:

例如: byte b = (byte)a  表达式中a是int类型(32位) b是byte类型(8位)

上例的强制类型转换中,  会将a的前24位截断,只保留最后的8位赋值给b



# 算数运算符

> 在Java中运算符的类型有算数运算符 关系运算符(比较运算符) 逻辑判断运算符(要求两个操作数都是boolean型) 赋值运算符 位操作运算符 

基本算数运算符有 + - * / %

其中+运算符不仅有加法的意义, 当操作数中有字符串时, 会执行字符串的拼接操作

-运算符不仅可以作为减肥的双目操作符, 也可以作为取反的单目操作符

> 标识符中数字不能放在首位
>
> char类型可以存储中文

>area:面积 perimeter:周长



# 关系运算符

关系运算符包括 < > >= <= == != instanceof 

> Java仅有一种三目运算符 ?(expression) ture_expression : false_expression

关系运算符的值是布尔类型, 也就是说只有true或false



**Scanner类**是java提供的系统类库, 可以录入键盘的输入内容, 仅需了解 无需深入探究



# 自增自减运算符

++ -- 单目操作符, 可以放在操作数前或后

放在操作数前时, 先执行自增/减 再参与表达式的运算

放在操作数后时, 如果是参与到算术表达式中, 代表当前操作数为原值 , 但是后面参与运算的同名操作数的值会加一

> 方便记忆
>
> ++
>
> 在前, 先加后用
>
> 在后, 先用后加
>
> --
>
> 在前, 先减后用
>
> 在后, 先用后减

示例:

```java
		int i=3;
        int j=4;
        int k=7;
        System.out.println(i++*++i-++j+k++);
        //(3*5)-5+7=17
        //上述表达式中, i++ 所以这里的操作数为3 *++3 这里的操作数为3+1+1=5
        //3*5=15
        //15-5+8=17
```

示例2

```java
        int i=3;
        int j=4;
        int k=5;

        System.out.println(i++- --j+k++*i--);
        //3-3+5*4=20
```

**技巧**: 将自增/减运算符先预运算出各操作数的值, 从左到右写出只有数值的算术表达式, 再按照数学运算规则去计算结果

# 运算符的优先级

对于算数运算符来说, 优先级与数学中的优先级相同, 可以将算数表达式作为数学表达式去运算

> 优先级从上到下, 同等优先级的运算符按照从左到右的顺序进行计算

| 优先级 | 运算符                           | 结合性         |
| ------ | -------------------------------- | -------------- |
| 1      | ()[]                             | 正常(从左到右) |
| 2      | ! ++ --(取反 自增 自减)          | 反(从右到左)   |
| 3      | * / %                            | 正常           |
| 4      | + -                              | 正常           |
| 5      | << >> >>>                        | 正常           |
| 6      | < > <- >= instanceof             | 正常           |
| 7      | == !=                            | 正常           |
| 8      | & (按位与)                       | 正常           |
| 9      | ^ (异或)                         | 正常           |
| 10     | \                                | 正常           |
| 11     | &&                               | 正常           |
| 12     |                                  | 正常           |
| 13     | ?:                               | 反             |
| 14     | = += -= *= /= (所有的赋值运算符) | 反             |

**需要注意的地方**: 结合性来说 有三类运算符是相反的, 从右到左 有: ! ++ -- ?:还有所有的赋值运算符

大小括号的优先级是最高的

自增自减 取反的优先级第二高

乘法除法取余的优先级第三高

加减法的优先级第四高

赋值运算符的优先级是最低的

> 位运算符 & | ^ << >> >>> 
>
> 按位与 按位或 异或 左移操作符 右移操作符 无符号右移操作符

# 进制的转换



计算机中通过原码储存正数, 补码储存负数

原码计算: 将十进制数字转换为2进制即为原码

如何计算补码:

先将负数取绝对值 然后转原码

将得到的原码取反得到反码( 0转1 1转0)

将反码+1得到补码(这里的补码为正数的补码)

补码最前面加上符号位1即为该负数的补码(存储值)



常见的进制:

2进制: 逢2进1 以0b开头 唯一可以直接被计算机识别的进制

8进制: 逢8进1 以0开头

16进制: 逢16进1 以0x开头 10-15的数字以a-f表示

10进制: 逢十进一

计算机中

一个位为bit(比特)

8位为byte(字节) 字节也是程序可以操作的最小单位(说明程序不能对单独的位进行操作, 必须一次对8个位进行操作)



计算机无法直接识别负数, 所以需要在最前面加上符号位

对于正整数来说, 原码, 反码 补码都是相同的

负数的原码 :正数的原码加上符号位1

反码: 原码的基础上将符号位外的位取反得到反码

补码: 反码加1