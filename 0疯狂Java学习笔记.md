所有的类都是引用类型

一个对象可以有多个引用, 当对象不存在引用时, 会被GC(垃圾回收器)回收销毁其内存空间

将一个数组变量指向另一个数组变量时, 需要两个数组的类型相兼容

Java中没有从底层实现真正的多维数组, 

例如:在Java里面的二维数组本质还是一维数组, 其数组元素储存引用变量, 引用变量指向另外的一维数组

如何定义多维数组: 

```java
type[][] arrName;
```

初始化

```java
arrName = new type[length][]
```

上述语句实际上相当于初始化了一个一维数组, 该一维数组的长度为length, 其数组元素为引用类型, 被系统自动初始化赋值为null

![image-20220427102048009](0疯狂Java学习笔记.assets/image-20220427102048009.png)

> 注意上图中定义了一个元素为对象的数组, 其数值在内存的存储方式如图所示

```java
a = new int[4][];
```

![image-20220427102324663](0疯狂Java学习笔记.assets/image-20220427102324663.png)

> 上图中该二维数组进行了(一维)初始化, 其堆内存存储方式跟一维数组非常类似

![image-20220427102454276](0疯狂Java学习笔记.assets/image-20220427102454276.png)

> 上图显示了二维数组对其数组元素进行了(二维)初始化

```java
b = new int[3][4];
```
![image-20220427103350502](0疯狂Java学习笔记.assets/image-20220427103350502.png)

> Java里面的三维数组也是一维数组, 其数组元素是二维数组, 二维数组里面的数组元素是一维数组, 所以Java多维数组的本质都是一维数组



# Array(数组)

在Array类里面的static修饰的方法可以直接调用来操作数组

例如:

```java
int binarySearch(type[] a, type key) 
```

可以用二分法在a数组中查找key, 返回其出现过的索引值 由于二分法的要求,a数组中的元素必须是从小到大排序才能正确查找 如果不包含则返回一个负数

```java
int binarySearch(type[] a, int formIndex, int toIndex, type key)
```

与前一个方法类似, 但是搜索范围限制在 formIndex到toIndex里面

```java
type[] copyOf(type[] originalArray, int length)
```

将originalArray数组复制为length长度的新数组

```java
type[] copyOfRange(type[]originalArryay, int form, int to)
```

与前方法类似, 但是将复制范围限制在form到to的索引范围内

```java
boolean equals(type[] a,type[] a2)
```

如果两个数组的长度和数组元素一一对应相同,则返回true 否则返回false

```java
void fill(type[] a,type value)
```

将a数组中的元素都赋值为value(注意这里的value需要是type类型的具体值)

```java
void fill(type[] a,int formIndex,int toIndex,type value)
```

与上一方法类似, 但是仅仅将索引范围内的元素赋值为value

```java
void sort(type[] a)
```

对a数组中的数组元素进行排序

```java
void sort(type[] a, int formIndex, int toIndex)
```

与上一方法类似,但是仅对范围内的元素进行操作

```java
String toString(type[] a)
```

将数组的元素按顺序拼接为字符串并返回, 每个元素中间用逗号和空格进行分割



在Java8中, 对Array类的功能进行了增强, 添加了新的工具方法(这些方法支持利用CPU的并发处理性能)

```java
void parallelSort(type[] a)
```

与sort方法类似, 但是增加了对并发运算的支持

> 用parallel开头的方法都表示该方法增加了对并行计算的支持

# 类(class)

类是一种特殊的数据类型, 在Java里面使用类定义的变量都是引用变量(全局变量)

类用于描述具有相同特征(相似属性)的某一类对象

对象是类的实例

在Java中对象是通过调用对应类的构造器类创建的

> 面向对象三大特征: 封装 继承 多态

在Java中提供了三个访问控制修饰符来实现封装

private protected public

extends关键字来实现继承

通过继承, 子类可以继承父类中的成员变量(类中方法外的变量)和方法

访问控制允许的情况下, 子类实例(对象)可以直接调用父类中方法

> 继承是实现类复用的重要手段, 类的复用也可以通过组合关系来实现 

```java
Father ft = new Child();
```

上述代码将子类的对象赋值给了父类变量, 使得该变量具有了多态性

> 如果是用组合关系来实现复用, 无法这样子来实现多态
>
> 灵活性差

Java中通过构造器来对类的实例进行初始化, 构造器支持重载

如果多个重载的构造器包含相同的代码, 可以考虑将代码块放入类的初始化代码块中

> 类的初始化代码块的执行会早于构造器

**当一个子类被初始化时, 系统会自动初始化它的所有父类**



# 类和对象

在Java中, 类是一种引用变量

面向对象程序设计的重要概念: 类 对象

> 对象是类的实例 类是对象的抽象

类的修饰符有 public final abstract, 也可以不加修饰符

类包含三种最常见的成员: 构造器 成员变量 方法

如果一个类不包含任何成员, 则其为空类

static修饰的成员不能访问非static成员, 只能访问其他用static修饰的成员

Java中通过new 关键字来调用对应类的构造器, 构造器会返回该类的一个实例

构造器是类创建对象的默认途径

没有构造器的类通常无法创建实例

如果没有自定义的构造器, 系统会自动为类生成一个构造器

# 成员变量

成员变量的修饰符有public, protected, private, static, final

(public protected private)三个修饰符只能出现其中之一

> Java中的方法组成成分: 修饰符 方法名 形参列表
>
> 代码块 返回值

static修饰的成员代表它属于类本身, 不属于单个实例.

所以static修饰的方法和成员变量也称为类方法 类变量

没有static修饰的方法 成员变量只能在类的单个实例里面调用(对象), 也叫做实例方法 实例变量

> 在大部分中文资料里面将static修饰的成员称为静态成员 (静态方法 静态变量), 但实际上特性跟动态没有相反的意思

静态成员无法直接访问非静态成员

# 构造器(构造方法)

构造器是一个特殊的方法(构造方法)

构造器不能声明返回值的类型, 也不能用void关键字来修饰

因为一旦用类型关键字来声明后, Java不会将其当作构造方法来执行, 而是作为普通方法来执行

构造方法的语法结构包括: 修饰符 构造方法名 形参列表

> 系统默认提供的构造方法是不带形参的

Java中的类可以用来:

定义变量

创建对象

调用类方法或者访问类变量

> 无符号右移>>> 



栈内存: 存储局部变量

堆内存: 储存全局变量(类变量)

Java里面的引用相当于C语言中的指针

> 指针: 储存了内存的地址值, 可以通过该地址值访问实际的对象

但是Java的引用对指针操作进行了封装, 减少了烦琐操作, 提高了编程效率

> 当一个对象没有任何引用变量指向它时, 该对象将被GC回收, 释放它占用的内存空间
>
> 将一个对象的所有引用变量都赋值为null时, 将导致没有任何引用变量指向该对象



**this**关键字总是指向调用该方法的对象

在构造器中this会引用该构造器正在初始化的对象

在方法中this会引用调用该方法的对象

this关键字主要用于在类中的一个方法里面访问该类的其他方法或类变量(避免需要重复创建对象来调用其他方法)

在Java中一个类的类成员可以直接调用其他成员, 相当于省略了this前缀(和加上this的效果是完全一样的)

**注意在static修饰的方法中是不允许使用this关键字的**

> 遵循了类成员(static 静态)无法访问非类成员(非static 非静态)的语法规定(静态成员无法访问非静态成员)

当一个类中的方法里有局部变量和全局变量同名, 会导致全局变量被覆盖掉, 这时必须使用this关键字才能访问全局变量

从功能上来看, 面向对象中的方法类似于结构化程序里面的函数, 但是Java里面的方法不能独立于对象, 必须定义在类里面

被static修饰的方法属于该类, 没有static修饰的方法属于该类的实例(对象)

Java中方法的特点:

1. 不能独立于类, 只能在类里面定义
2. 只能属于类或者属于类的实例
3. 不能独立执行, 只能被类或对象调用



调用方法传给方法的参数值为实参

方法中负责接收的变量(参数)也被称为形参

Java中只有一种参数传递方式: 值传递

> 值传递实际上将实参的数值赋值给了形参, 对形参做的操作不会对实参产生影响

![image-20220428112756882](0疯狂Java学习笔记.assets/image-20220428112756882.png)

> 上图表示了从main方法中将a, b参数传递给swap方法中的a, b参数时, 内存空间中值的储存方式
>
> 注意每个方法在执行时, 都会创建属于该方法的栈(stack)内存

但是如果传入的值是引用变量时, 虽然实参跟形参实际上还是两个不同的引用变量, 但是它们都指向同一个对象(内存地址)

所以对形参进行操作时, 实际上会访问该形参指向的对象进行操作, 导致访问实参时候也会发现该对象在操作后会发生的改变

> 要注意的时, 如果是将形参重新指向其他对象或者直接置为null, 不会对形参的指向产生影响

在Java1.5中, 增加了新功能: 允许定义形参个数不定(可变)的方法,在形参类型后加... 表达该形参可以接受多个参数值, 并且多个参数值会作为数组传入

> 注意类型必须指定, 个数可以不定
>
> 并且一个方法只能有一个个数可变的形参

```java
public static void test1(int a, String... books);
public static void test2(int a, String[] books);
```

上述两行代码定义的方法对于编译器来说参数相同, 不可以能进行方法重载

两个方法里都可以把books作为数组处理. 但是调用它们时候必须用不同的方式

```java
test1(5,"哈利波特","简爱");
test2(5,new String[]{"哈利波特","简爱"});
```

> 写代码时候最好选用一种默认的风格
>
> 比如循环尽量用for循环去写
>
> for循环里面的条件语句尽量使用<>大于小于号而不是大于等于小于等于<= >=号

# 递归

递归就是在一个方法里面调用方法它本身

> 递归一定要向已知方向递归, 防止出现死循环

# 方法重载

Java允许同一个类里有多个重名的方法, 但是要求重名的方法对应的形参列表不能相同

如果一个类中包含多个方法名相同, 但是形参列表不同的方法, 就称为方法重载

(返回值不同不能作为方法重载的条件)

在Java中确定一个方法需要**三要素**

1. 调用者 方法的所属者, 可以是类或对象
2. 方法名 方法对应标识符
3. 形参列表 调用方法时候, 实参的值将被赋值给形参

形参个数可变的方法也可以被重载

```java
public void test(String... args){}
public void test(String args){}
//public void test(String[] args){}
```

第二行代码传入参数只有一个, 可以作为test方法的方法重载

但是第三行代码不行

> 不建议重载形参个数可变的方法, 因为会导致程序可读性的下降

# 变量

Java中变量分为局部变量和成员变量

局部变量有形参 方法内定义的局部变量 (代码块内定义的代码)

成员变量有 实例变量 static类变量(都是在方法外定义的变量)

> 注意: static类变量的生存周期和其所属的类相同
>
> 但是非static变量的生命周期是和其所属的实例相同的

>类的生命周期: 类加载, 类验证, 类准备, 类解析, 类初始化.....

类变量: 类成员变量

实例变量: 实例成员变量

两者统称成员变量

> 当一个实例修改非static变量时候不会影响到同一个类的其他实例
>
> 但是当其修改static变量时候, 由于修改的是类成员变量, 会导致该类的其他实例读取该变量时候也会发现被修改了

**成员变量会被系统自动初始化, 初始化的默认赋值与数组动态初始化的赋值规则完全相同**

> Java中可以通过实例来修改static修饰的成员变量, 但是这种做法会导致代码的可读性, 明确性都受到影响
>
> 建议使用通过类来修改static变量的做法替换

> 尽量避免在编程时候出现局部变量与成员变量同名的情况, 提高代码的可读性

局部变量的生命周期:

1. 形参的作用域为整个方法
2. 方法内定义的变量的作用域为从定义它的那段代码开始, 到方法结束
3. 代码块的局部变量 作用域: 从定义它的代码开始到代码块结束

局部变量除了形参, 都必须显式初始化后才能使用

成员变量不需要显式初始化, 系统提供的构造器会自动将其初始化

两个成员变量的标识符不允许相同

![image-20220429100028459](0疯狂Java学习笔记.assets/image-20220429100028459.png)

上图展示了类成员变量和实例成员变量在内存空间中的储存差别

引用变量里面保存的是对应实例的内存地址

> 栈内存里面的变量一般不需要GC进行内存回收, 因为它的内存空间会随着方法或代码块的运行结束而销毁

局部变量只能保存基本类型数值或者实例的引用

所以局部变量所需的内存空间很小

无脑使用成员变量不符合软件开发规范将导致

1. 成员变量的作用域过大, 程序的内聚性降低
2. 成员变量的生存时间过长, 导致内存开销变大

需要用到成员变量的常见情形:

1. 多个方法都需要用到该变量值
2. 该变量用于描述一个类的固有信息

良好的软件开发规范应该是尽可能的缩小一个变量的作用域, 不占用多余的内存时间

# 隐藏和封装

Java中的类和实例的成员变量可以进行封装来向外界隐藏对象的内部信息

面向对象三大基本特征: 封装(Encapsulation) 继承(implement) 多态(polymorphism)

封装: 将对象的内部进行隐藏, 不允许外部程序直接访问成员变量, 在类的内部提供对应的方法来实现对成员变量的操作

封装可以实现:

1. 对类外面隐藏类的实现细节
2. 提供方法来操作成员变量, 在方法里面可以加入安全限制逻辑
3. 保证成员变量的完整性
4. 提高代码的可维护性

封装在Java里面通过访问控制修饰符来实现

Java里面有3种访问控制符: private protected public

还有一种情况是不加任何访问控制符的默认级别

访问控制级别从小到大

private -> default -> protected -> public

访问控制级别表

| 范围       | private | default | protected | public |
| ---------- | ------- | ------- | --------- | ------ |
| 同一个类   | 1       | 1       | 1         | 1      |
| 同一个包   |         | 1       | 1         | 1      |
| 子类中     |         |         | 1         | 1      |
| 全局范围内 |         |         |           | 1      |

```java
class Outer{
    class Inner{}
}
```

上述代码定义了一个Outer外部类和Inner内部类

访问控制符中, private和protected不能用于修饰外部类

> 访问控制符可以用于控制类的成员能否被其他类访问

> 访问控制符可以用于修饰类成员和类本身

> 对于外部类, 只有一种访问修饰符可以用public
>
> 两种状态: 默认 public

一份Java源代码文件中, 如果所有类都没有用public修饰, 则源代码文件名可以取任意的.

一个Java源代码中只能有一个public修饰的类, 且文件名必须与public修饰的类名相同

JavaBean规范: Java类的每个成员变量都用private修饰符修饰, 并且每个成员变量都需要提供对应的setter getter方法(必须是用public修饰的)

模块化程序设计特点:

1. 高内聚 (尽量将模块的内部数据, 功能实现向外界隐藏, 避免受到外界干扰)
2. 低耦合 (提供封装好的方法给外部使用)

访问控制符使用建议:

1. 大部分的成员变量都用private修饰, 仅当成员变量被static修饰时或者作为全局变量使用时才考虑用public修饰
2. 如果一个类中的方法是提供给其子类重写用的, 应该用protected修饰
3. 类的构造器应该用public修饰, 来运行其他类创建该类的实例, 大部分外部类也应该用public修饰

# package

package(包)提供了类的多层命名空间, 用于解决类文件管理问题, 命名冲突

将一组功能相关的类放在同一个package下, 就组成了逻辑上的类库单元

```java
package packageName;
```

上述代码应该放在源代码的第一行, 意味着该源代码中定义的所有类都属于这个包

一个源文件只能对应一个包

>当源文件没有显式指定对应包名时, 则该源文件属于默认包

> 同一个包中的类文件不需要放在同一目录下(只需要它们都在CLASSPATH包含的目录下即可)
>
> 不同包的类文件不能放在同一目录下, 避免类名冲突

> javac -d . Hello.java
>
> 使用-d选项编译时, 会自动建立包结构对应的文件目录结构
>
> 这样子避免了同名类文件的冲突, 同名类文件无法在同一目录下存放

Array常用方法:

```java
import java.util.Arrays;
System.out.println(Arrays.toString(arrayName));
java.util.Arrays.toString(arrayNmae);
```



![image-20220505095746576](0疯狂Java学习笔记.assets/image-20220505095746576.png)

> 标准Java项目文件夹结构

按照行业标准, 包名应该只由小写字母组成, 并且应该由有意义的单词组成

> 调用另一个包包含的类时, 需要在类名前加上包前缀来调用
>
> 类全名: 包名+类名
>
> 当两个类处于同一个包中时,可以省略包名

使用包名时必须写全名, 不可省略任何部分

一个源代码只能包含一个package语句

import语句应出现在package语句之后, 类定义语句之前

impoer语句可以用*来导入该包下面的所有类, 但是子包不会被导入

> 在Java中, 父包与子包之间没有任何关系
>
> 仅仅作为认知
>
> 在Java中包名是一个整体, 不可进行缩写, 只能整个省略

在Java中会默认导入java.lang中的所有的包

因此在java.lang下面的所有类如 String System都不需要显示导入就可以直接使用

> 当import的包里面含有重名的类时候, 必须使用包名+类名来导入类

java1.5中增加了静态导入的方法

```java
import static java.lang.System.*;
import static java.util.Arrays.toString;
```



静态导入只能用于导入指定类中的静态成员

静态导入在源代码文件中应该于普通导入处于同一位置

> 使用静态导入可以省略包名以及类名, 直接使用导入的静态成员

> 接口和枚举都是一种特殊类

**Java常用类库包**

java.lang 包含了java的核心类如String Math System Thread 默认被所有的Java源代码文件导入

java.util 包含了大量工具类 集合框架类 如: Arrays List Set

java.net 包含网络编程相关类

java.io 包含IO(输入/输出)编程相关类

java.text 包含格式化相关的类

java.sql 包含数据库编程相关的类

java.awt 包含可视化窗口相关的类

java.swing 包含Swing GUI编程相关的类

# 构造器

> 一个类可以有多个构造器(构造器重载:类似于方法重载)

自动初始化:

将整数型赋0 浮点数型赋0.0

布尔型 false 引用类型赋 null



Java程序创建对象的流程:

new 关键字调用构造器

系统分配对象的内存空间, 进行默认初始化

> 疑问: 这里是默认构造器的本质吗?

执行自定义构造器

返回对象的地址(相当于返回一个引用变量)

**当自定义构造器提供时, 系统将不会提供默认构造器(无参数构造器)**

用权限修饰符修饰构造器可以控制类的对象创建权限

protected使得只有子类可以调用该类的构造器

private可以阻止其他类调用该类的构造器



构造器重载: 一个类中包含多个构造器, 构造器的形参列表互不相同

构造器重载使得Java的同一个类可以包含多个初始化逻辑, 有多种方式来初始化对象

> 构造器必须与类名相同

```java
public class Test{
    public Test(){}
    public Test(int num){}
    public Test(int num,int num02){
        this(2);
        //this();
    }
}
```

在上述代码中, 构造器用this关键字调用了其他构造器

注意一个构造器里面仅可调用一次

> 之所以提供构造器重载的特性是为了实现代码的可复用性
>
> 避免出现重复的代码段 降低代码维护成本

# 继承

> 面向对象三大特征: 继承 封装 多态

继承是实现代码复用的重要手段

Java中的继承为单继承, 一个子类只能有一个父类

> Java舍弃了C++中复杂的多继承特性

> 但是也可以通过父类继承间接父类, 来使得子类间接继承多个(间接)父类

**在Java中如果一个类没有显示指定一个类作为直接父类, 则会默认指定java.lang.Object类为其直接父类**

**java.lang.Object是Java中所有类的直接/间接父类**

```java
public class SubClass extends SuperClass{}
```

上述代码中通过extends关键字, SubClass类继承了父类SuperClass

> extends原意为扩展, 所以也可以说子类是对父类的扩展

> 注意Java中子类无法继承父类的构造器

derive(派生) 父类派生了子类

extends(继承) 子类继承了父类

derive extends都是描述同一动作, 但是角度/方向不同

子类大部分情况下都是在父类的基础上增加新的成员变量和方法

但是存在例外情况: 方法重写(覆盖) (Override)

方法重写(override)与方法重载(overload)是完全不同的概念

方法重写:

子类中存在于父类同名的方法称为方法重写

方法重写规则: 两同两小一大

两同: 方法名 形参列表必须相同 (是否被static修饰符修饰也需要保持一致)

两小: 子类中的方法返回值**类型**必须小于或等于父类方法的返回值类型

子类方法抛出的异常类也应该比父类方法更小或相等

一大: 子类方法的访问权限应该比父类方法的更大或相等

> 注意父类中用private修饰的方法对于子类来说是不存在的(隐藏) 这时候在子类中定义同名的方法不是方法重写

super关键字用于在子类中调用被覆盖的父类方法

> super关键字不能出现在static修饰的方法中
>
> 但是可以调用被static修饰的方法

super关键字也可以用于在子类中调用被隐藏的父类变量

> 当子类中定义了与父类重名的变量时会导致父类变量被隐藏, 子类可以通过super关键字调用被隐藏的父类变量

程序查找变量的顺序(优先级)为:

1. 找该方法中的局部变量
2. 找该类中的成员变量
3. 找父类中的成员变量
4. 按结构遍历所有间接父类的成员变量直至最终的java.lang.Object
5. 最终仍无法找到变量将出现编译错误

找到同名变量后不会再执行后续步骤

![image-20220505172804617](0疯狂Java学习笔记.assets/image-20220505172804617.png)

```java
Son s=new Son();
//int num=s.tag;
int num =((Parent)s).tag
```

上述代码显示了在创建子类对象后, 用(Parent)来调用父类中被隐藏的变量

**子类可以用super关键字来调用父类的构造器**



