# 向上转型

由于子类实质上是特殊的父类, 因此子类对象可以直接赋值给父类引用变量, 这时不会发生任何类型转换, 系统会自动完成 向上转型(upcasting)

Object类是接口类的唯一间接父类

可以用向上转型将接口类型引用变量赋予Object类型引用变量

**向上转型如果发生在引用类型间, 需要两个操作数为继承关系**

**基本数据类型的自动转型也是向上转型**

```java
Son s=new Son();
Father f=s;
```

上述代码实现了引用类型的向上转换

1. 向上转型: 父类类型引用变量指向子类对象, 接口类型引用变量指向子类对象
2. 向下转型: 子类类型引用变量指向父类对象

# 向下转型

Java中通过强制转换来实现向下转型

基本数据类型的向下转型会导致部分数据丢失

```java
Father f=new Father();
Son s=(Son)f;
```

上述代码实现了引用类型的向下转换

# instanceof运算符

```java
Father f1=new Father();
Son s1=(Son)f1;
//上述代码会抛出java.lang.ClassCastException错误
Son s2=new Son();
Father fs=(Father)s2;
//正确的多态实现
```

```java
Father f1 = new Father();
if (f1 instanceof Son) {
    Son s1 = (Son) f1;
}
//可以用instanceof运算符来判断是否可以成功转换, 避免抛出ClassCastException错误
//上述if判断将为false, 不会执行代码块里面的内容
```

instanceof运算符: 当前面的操作数是后面操作数的同一个类 子类 实现类的实例则返回true, 否则返回false

要求前面的操作数为实例/对象, 后面的操作数为类

instanceof运算符一般与(type)强制转换符配合使用, 先用instanceof判断是否可以进行强制转换, 再用强制类型转换符进行转换, 保证代码的健壮性

# 多态

Java中的引用变量同时有两个类型: 编译时类型 运行时类型

编译时类型由声明时使用的类型决定

运行时类型由该变量指向的对象决定

当编译时类型与运行时类型不同时, 就可能出现多态

多态是什么:将父类类型变量指向其子类对象

多态的特征: 同类型的变量, 调用同一方法时出现不同的行为

```java
FatherClass polymophicVar=new SonClass();
```

它的编译类型为FatherClass 运行类型是SonClass

当使用polymophicVar调用子类中覆盖了父类的方法时, 会出现多态

注意: ploymophicVar只能调用父类中的存在方法, 调用方法时会表现出子类中覆盖方法的行为 

> 可以通过反射来执行子类中的方法

> 由于子类实质上是特殊的父类, 因此子类对象可以直接赋值给父类引用变量, 这时不会发生任何类型转换, 系统会自动完成 向上转型(upcasting)

> 注意实例变量没有多态性, 用ploymophicVar只能调用父类中的实例变量, 不能调用子类中的实例变量

> 本质是引用变量只能调用其编译时类型具有的方法, 但是在运行方法时会优先执行它运行时类型里面的方法

```java
int a=1;
(double)a;
```

上述代码使用了强制类型转换符将a变量从int类型转换为double类型

使用强制类型转换时注意:

基本数据类型只能在整数型 字符型 浮点型之间进行相互转换, 布尔类型无法转换

引用类型的转换只能在具有继承关系的两个类型间进行

>将父类类型实例强制转换成子类类型时, 其运行时类型必须是子类类型, 否则会发生ClassCastException错误

